---
title: "IQ_Script"
author: "Douglas Venegas"
date: "2024-10-28"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cerulean
    highlight: tango
    code_folding: hide
    number_sections: true
  pdf_document:
    toc: true
    toc_depth: '3'
affiliations: "CENIBiot-CENAT"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,       
  message = FALSE,   
  warning = FALSE,   
  fig.width = 7,     
  fig.height = 5,    
  fig.align = 'center',
  cache = TRUE      
)
knitr::opts_chunk$set(echo = TRUE)
```


Run the script to line 910 for an index based on your annotation library or run the script to line 64 and jump to line 910 for IQ based on NPAtlas annotations.

# Packages instalation

Load or install pacman to streamline package management

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load("RColorBrewer", "tidyverse", "readxl", "rvest", "dplyr", "tidyr", "igraph", "visNetwork", "readr", "ggplot2", "ggraph", "graphTweets", "writexl", "proxy", "httr")
# Set JAVA_HOME environment variable for rJava
Sys.setenv(JAVA_HOME = 'C:/Program Files/Java/jdk-17')

```

# Inputs

Load network from a .graphML file. Change the file name as necessary
```{r}
graphml <- read_graph("Data/network_Crusemann.graphml", format = "graphml")
Metadata <- read_delim("Data/Metadata_Cruseman.csv", 
                       delim = ";", escape_double = FALSE, trim_ws = TRUE)

```

# List of directories to create

```{r}
Dirs <- c("Data/CSV_IQ", "Data/IQ_Plot","Data/CSV_IQNPA", "Data/IQNPA_Plot")
for (dir in Dirs) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
```

# Get node and edge data from the graph and prepare data
```{r}
if (is_igraph(graphml)) {
  df_edges <- as_data_frame(graphml, what = "edges")
  df_nodes <- as_data_frame(graphml, what = "vertices")
}

# Calculate total nodes per sample
Total_nodes_per_sample <- df_nodes %>%
  select(id, UniqueFileSources, MQScore) %>% 
  separate_rows(UniqueFileSources, sep = "\\|") %>%  
  group_by(UniqueFileSources)

# Merge with metadata to get strain information
Total_nodes_per_strain <- merge(Total_nodes_per_sample, Metadata, 
                                by.x = "UniqueFileSources", by.y = "filename", all.x = TRUE)

# Select relevant columns for analysis
Total_nodes_per_strain <- Total_nodes_per_strain %>%
  select(id, ATTRIBUTE_strain, MQScore)

# Count total nodes per strain
Total_nodes <- table(Total_nodes_per_strain$ATTRIBUTE_strain)
Total_nodes <- as.data.frame(Total_nodes)
colnames(Total_nodes) <- c("ATTRIBUTE_strain", "Count")
```

# Extract index inputs for MQS

```{r}

score_MQS <- Total_nodes_per_strain %>%
  filter(!is.na(MQScore) & MQScore != "")

# Count nodes with annotated strain information
nodes_annotated_strain <- table(score_MQS$ATTRIBUTE_strain)
nodes_annotated_strain <- as.data.frame(nodes_annotated_strain)
colnames(nodes_annotated_strain) <- c("ATTRIBUTE_strain", "Count")

# Define strata for MQScore
MQS_breaks <- seq(0.00, 1, by = 0.05)
strata_MQS <- setNames(
  lapply(seq_along(MQS_breaks)[-length(MQS_breaks)], function(i) c(MQS_breaks[i], MQS_breaks[i + 1])),
  paste0(sprintf("%.2f", MQS_breaks[-length(MQS_breaks)]), "-", sprintf("%.2f", MQS_breaks[-1])))

## Function to stratify and count values, ignoring NAs
stratify_and_count_unique <- function(df, column, strata) {
  unique_df <- df %>% 
    group_by(id) %>% 
    slice(1) %>%  # Count only the first occurrence of each unique identifier (id) in the specified column
    ungroup()
  
  # Count unique values for each stratum
  counts <- sapply(strata, function(range) {
    sum(unique_df[[column]] >= range[1] & unique_df[[column]] < range[2], na.rm = TRUE)
  })
  
  return(counts)
}

## Create lists to store individual dataframes and strata counts
individual_dfs <- list()
strata_counts <- list()

## For each sample, create an individual dataframe and calculate strata counts
for (sample_name in unique(score_MQS$ATTRIBUTE_strain)) {
  individual_df <- score_MQS %>%
    filter(ATTRIBUTE_strain == sample_name) %>%
    select(id, MQScore)
  
  # Count unique values in each stratum for MQScore
  MQScore_counts <- stratify_and_count_unique(individual_df, "MQScore", strata_MQS)
  
  # Ensure that the strata names are consistent
  counts_df <- data.frame(
    Stratum = names(strata_MQS),
    MQScore_Count = MQScore_counts
  )
  
  # Store the count dataframe in the list
  strata_counts[[sample_name]] <- counts_df
  
  # Assign the individual dataframe to the list
  individual_dfs[[sample_name]] <- individual_df
}

## Save each individual dataframe and the strata counts to CSV files in the CSV_IQ folder
for(sample_name in names(individual_dfs)) {
  write.csv(individual_dfs[[sample_name]], file = paste0("Data/CSV_IQ/", sample_name, "_data_MQS.csv"), row.names = FALSE)
  
  
  # Assign each dataframe to a variable in the R environment
  assign(paste0(sample_name, "_data"), individual_df)
  assign(paste0(sample_name, "_strata_counts"), counts_df)
}

## Create a data frame to store strain names
strains <- data.frame(Total_nodes$ATTRIBUTE_strain)
colnames(strains) <- c("strain")
strains <- strains$strain

## Create an empty dataframe for the summary
shannon_summary_MQS <- data.frame(Strain = character(), Shannon_Index = numeric(), stringsAsFactors = FALSE)

## Iterate over each strain
for (strain in strains) {
  # Name of the corresponding dataframe
  df_name <- paste0(strain, "_strata_counts")
  
  # Check if the dataframe exists
  if (exists(df_name)) {
    df_strata_counts <- get(df_name)
    
    # Obtain the total count for this strain from Total_nodes
    total <- Total_nodes$Count[Total_nodes$ATTRIBUTE_strain == strain]
    
    # Check that the total is greater than zero
    if (total > 0) {
      # Calculate the proportion (pi) for each stratum and add it as a new column
      df_strata_counts$pi <- df_strata_counts$MQScore_Count / total
      
      # Add a column with the total count
      df_strata_counts$Total <- total
      
      # Calculate pi * ln(pi), handling the case where pi = 0
      df_strata_counts$pi_ln_pi <- ifelse(df_strata_counts$pi > 0, df_strata_counts$pi * log(df_strata_counts$pi), 0)
    } else {
      # If the total is zero, assign NA to the new columns
      df_strata_counts$pi <- NA
      df_strata_counts$Total <- NA
      df_strata_counts$pi_ln_pi <- NA
    }
    
    # Calculate the Shannon index as -sum(pi * ln(pi))
    shannon_index <- -sum(df_strata_counts$pi_ln_pi, na.rm = TRUE)
    
    # Add the Shannon index as a new column (same for all strata)
    df_strata_counts$shannon_index <- shannon_index
    
    # Append the Shannon index to the summary
    shannon_summary_MQS <- rbind(shannon_summary_MQS, data.frame(Strain = strain, Shannon_Index = shannon_index))
    
    # Select only the relevant columns before saving
    df_strata_counts <- df_strata_counts[, c("Stratum", "MQScore_Count", "pi", "Total", "pi_ln_pi", "shannon_index")]
    
    # Save the updated dataframe to a CSV file
    write.csv(df_strata_counts, file = paste0("Data/CSV_IQ/", df_name, "_SI_MQS.csv"), row.names = FALSE)
  } else {
    warning(paste("The dataframe", df_name, "does not exist."))
  }
}
```

## Save Shannon Index summary to a CSV file
```{r}
write.csv(shannon_summary_MQS, file = "Data/CSV_IQ/1_MQS_shannon_index_summary.csv", row.names = FALSE)

```

# Extract index input: COS_score

```{r}

# Get cosine scores where node2 matches the id in score_MQS
score_COS_node1 <- df_edges %>%
  select(node1, cosine_score, node2) %>%
  semi_join(score_MQS, by = c("node2" = "id")) # Retrieve cosine values from node to node

# Get complementary cosine scores where node1 matches the id in score_MQS
score_COS_node2 <- df_edges %>%
  select(node2, cosine_score, node1) %>%
  semi_join(score_MQS, by = c("node1" = "id")) # Retrieve complementary cosine values

# Combine interactions into a single dataframe
combined_interactions <- bind_rows(
  score_COS_node1 %>% mutate(direction = "Score_COS_node1"),
  score_COS_node2 %>% mutate(direction = "Score_COS_node2")
) # Add a new column called direction to indicate the source node of the interaction.

# Create a combined node column based on direction
combined_interactions <- combined_interactions %>% mutate(
  combined_nodes = ifelse(direction == "Score_COS_node1",
                          paste(node1, node2, sep = "/"),
                          paste(node2, node1, sep = "/"))
) # If “Score_COS_node1”, concatenate node1 and node2; else, concatenate node2 and node1.

# Separate combined nodes into nodeA and nodeB
combined_interactions <- combined_interactions %>%
  separate(combined_nodes, into = c("nodeA", "nodeB"), sep = "/") # Assign nodeA as the node of interest.

## Remove rows where nodeA and nodeB are the same (singlets)
combined_interactions <- combined_interactions[combined_interactions$nodeA != combined_interactions$nodeB, ]

# Select relevant columns for cosine scores
score_COS <- combined_interactions %>%
  select(nodeA, cosine_score) # Filter cosine values for the node of interest.

# Merge cosine scores with node metadata
score_COS <- merge(score_COS, df_nodes, by.x = "nodeA", by.y = "id", all = TRUE)  
# Note: MQS values are repeated when there are multiple COS scores, as intended.

# Clean up score_COS dataframe
score_COS <- score_COS %>% select(nodeA, cosine_score, UniqueFileSources) %>% 
  filter(!is.na(cosine_score) & cosine_score != "") %>% 
  separate_rows(UniqueFileSources, sep = "\\|") %>%  
  group_by(UniqueFileSources)

# Rename columns for clarity
colnames(score_COS) <- c("id", "Cosine_score", "UniqueFileSources")

# Merge with metadata to include additional information
score_COS <- merge(score_COS, Metadata, 
                   by.x = "UniqueFileSources", by.y = "filename", all.x = TRUE)

# Final selection of relevant columns
score_COS <- score_COS %>% select(id, Cosine_score, ATTRIBUTE_strain)

# Define strata for cosine score
cos_breaks <- seq(0.70, 1.00, by = 0.05) # Define breaks for cosine scores
strata_COS <- setNames(
  lapply(seq_along(cos_breaks)[-length(cos_breaks)], function(i) c(cos_breaks[i], cos_breaks[i + 1])),
  paste0(sprintf("%.2f", cos_breaks[-length(cos_breaks)]), "-", sprintf("%.2f", cos_breaks[-1])))


## Function to stratify and count values, ignoring NAs
stratify_and_count <- function(df, column, strata) {
  counts <- sapply(strata, function(range) {
    sum(df[[column]] >= range[1] & df[[column]] < range[2], na.rm = TRUE) # Count values within each stratum
  })
  return(counts)
}

## Create lists to save individual df and strata counts
individual_dfs_COS <- list()
strata_counts_COS <- list()

## For each sample, create an individual df and strata counts
for (sample_name in unique(score_COS$ATTRIBUTE_strain)) {
  individual_df <- score_COS %>%
    filter(ATTRIBUTE_strain == sample_name) %>%
    select(id, Cosine_score)
  
  # Counting unique values in each stratum for Cosine score
  cosine_score_counts <- stratify_and_count(individual_df, "Cosine_score", strata_COS)
  
  # Create a dataframe for the counts
  counts_df <- data.frame(Stratum = names(cosine_score_counts), Count = cosine_score_counts)
  
  # Store count dataframe in the list
  strata_counts_COS[[sample_name]] <- counts_df
  
  # Assign the individual dataframe to the list
  individual_dfs_COS[[sample_name]] <- individual_df
}

## Save each individual dataframe and the strata counts to CSV files in the CSV_IQ folder
for(sample_name in names(individual_dfs_COS)) {
  write.csv(individual_dfs_COS[[sample_name]], file = paste0("Data/CSV_IQ/", sample_name, "_data_COS.csv"), row.names = FALSE)

  
  # Assign each dataframe to a variable in the R environment
  assign(paste0(sample_name, "_data_COS"), individual_dfs_COS[[sample_name]])
  assign(paste0(sample_name, "_strata_counts_COS"), strata_counts_COS[[sample_name]])
}

## name list (strains)
strains <- unique(Total_nodes$ATTRIBUTE_strain)

## df for summary
shannon_summary_cos <- data.frame(Strain = character(), Shannon_Index = numeric(), stringsAsFactors = FALSE)

## Iterate each strain
for (strain in strains) {
  # df name
  df_name <- paste0(strain, "_strata_counts_COS")
  if (exists(df_name)) {
    df_strata_counts <- get(df_name)
    
    # obtain total node for each strain from total_nodes
    total <- Total_nodes$Count[Total_nodes$ATTRIBUTE_strain == strain]

    if (total > 0) {
      if ("Count" %in% colnames(df_strata_counts)) {
        # Calculate the proportion (pi) for each stratum and add it as a new column
        df_strata_counts$pi <- df_strata_counts$Count / total
        
        # add a column with the total number
        df_strata_counts$Total <- total
        
        # calculate pi * ln(pi), handling the case of pi = 0
        df_strata_counts$pi_ln_pi <- ifelse(df_strata_counts$pi > 0, df_strata_counts$pi * log(df_strata_counts$pi), 0)
      } else {
        warning(paste("The column 'Count' does not exist in the dataframe", df_name))
        df_strata_counts$pi <- NA
        df_strata_counts$Total <- NA
        df_strata_counts$pi_ln_pi <- NA
      }
    } else {
      df_strata_counts$pi <- NA
      df_strata_counts$Total <- NA
      df_strata_counts$pi_ln_pi <- NA
    }
    # Calculate SI
    shannon_index <- -sum(df_strata_counts$pi_ln_pi, na.rm = TRUE)
    df_strata_counts$shannon_index <- shannon_index
    shannon_summary_cos <- rbind(shannon_summary_cos, data.frame(Strain = strain, Shannon_Index = shannon_index))
    df_strata_counts <- df_strata_counts[, c("Stratum", "Count", "pi", "Total", "pi_ln_pi", "shannon_index")]
    
  
    write.csv(df_strata_counts, file = paste0("Data/CSV_IQ/", df_name, "_SI_COS.csv"), row.names = FALSE)
  } else {
    warning(paste("The dataframe", df_name, "dont exist."))
  }
}

```

## Save Shannon Index summary (COS) to a CSV file
```{r}
write.csv(shannon_summary_cos, file = "Data/CSV_IQ/1_COS_shannon_index_summary.csv", row.names = FALSE)
```

# Annotated nodes per sample
```{r}
Proportion_Annotated_nodes= merge(nodes_annotated_strain, Total_nodes, by.x = "ATTRIBUTE_strain", by.y = "ATTRIBUTE_strain")
Proportion_Annotated_nodes$Ans=Proportion_Annotated_nodes$Count.x/Proportion_Annotated_nodes$Count.y
Proportion_Annotated_nodes= Proportion_Annotated_nodes %>% select(-Count.x, -Count.y)

```

# IQ
```{r}
IQ <- merge(Proportion_Annotated_nodes, shannon_summary_cos, by.x = "ATTRIBUTE_strain", by.y = "Strain")
IQ <- merge(IQ, shannon_summary_MQS, by.x = "ATTRIBUTE_strain", by.y = "Strain")
colnames(IQ)= c("ATTRIBUTE_Strain", "Ans", "Hcos", "Hmqs")

# Scaling
IQ$Hcos[is.na(IQ$Hcos)] <- 0
IQ$Hmqs[is.na(IQ$Hmqs)] <- 0
IQ$Ans[is.na(IQ$Ans)] <- 0
IQ$Hmqs <- (IQ$Hmqs - min(IQ$Hmqs)) / (max(IQ$Hmqs) - min(IQ$Hmqs))
IQ$Hcos <- (IQ$Hcos - min(IQ$Hcos)) / (max(IQ$Hcos) - min(IQ$Hcos))
IQ$IQ= (IQ$Ans+IQ$Hcos+IQ$Hmqs)/3
IQ = merge(IQ, Metadata, by.x = "ATTRIBUTE_Strain", by.y = "ATTRIBUTE_strain")
IQ= IQ %>% select(IQ,Hmqs,Hcos, Ans, ATTRIBUTE_Bacteria, ATTRIBUTE_Strain)
IQ_T <- IQ %>%
  distinct()
num_unique_strains <- nrow(IQ)
```

# Plots

## IQ by strain
```{r}

IQ_plot = ggplot(IQ, aes(x = reorder(ATTRIBUTE_Strain, -IQ), y = IQ, fill = ATTRIBUTE_Bacteria)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "Black", width = 0.7, show.legend = TRUE) +  
  theme_classic() + 
  labs(x = "Strain",
       y = "IQ",
       fill = "Bacteria") +  # Legend label
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),  
    axis.text.x = element_text(angle = 90, hjust = 1, size = 8),  
    axis.text.y = element_text(size = 22),
    axis.title.y = element_text(size = 22),
    axis.title.x = element_text(size = 14),  
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 22),  
    legend.title = element_text(size = 22)  
  )+ scale_fill_viridis_d()

IQ_plot 


ggsave("Data/IQ_Plot/1_IQ_Plot.png", plot = IQ_plot, width = 15, height = 8)

```

## Distribution plot
```{r}

summary_data <- IQ %>%
  group_by(ATTRIBUTE_Bacteria) %>%
  summarise(
    mean_IQ = mean(IQ, na.rm = TRUE),  # Calculate mean IQ
    sd_IQ = sd(IQ, na.rm = TRUE),      # Calculate standard deviation of IQ
    .groups = 'drop'                   # Drop grouping structure
  )

Distribution_plot = ggplot() +
  geom_point(data = IQ, aes(x = ATTRIBUTE_Bacteria, y = IQ), 
             shape = 1, color = "blue", size = 1.5, alpha = 0.6) +  # Puntos individuales
  geom_errorbar(data = summary_data, 
                aes(x = ATTRIBUTE_Bacteria, ymin = mean_IQ - sd_IQ, ymax = mean_IQ + sd_IQ), 
                width = 0.1, color = "black") +  # Barras de error para la media ± SD
  geom_point(data = summary_data, aes(x = ATTRIBUTE_Bacteria, y = mean_IQ), 
             shape = 1, color = "blue", size = 1) +  # Puntos de media
  labs(
    x = "", 
    y = "IQ") +  # Etiquetas de los ejes
  theme_classic() +
  theme(
    axis.title.x = element_text(size = 14),  
    axis.title.y = element_text(size = 14),  
    axis.text.x = element_text(size = 12),    
    axis.text.y = element_text(size = 12),    
    axis.line = element_line(size = 1)        
  ) 

Distribution_plot

# Save the Distribution Plot as a PNG file
ggsave("Data/IQ_Plot/2_Distribution_plot.png", plot = Distribution_plot, width = 15, height = 8)

```

## Boxplot
```{r}

Boxplot = ggplot(IQ, aes(x = ATTRIBUTE_Bacteria, y = IQ)) +
  geom_boxplot(outlier.shape = NA, fill = NA, color = "black", width = 0.1) + 
  geom_point(aes(color = "Individual Points"), shape = 1, size = 3, alpha = 0.6) +  
  scale_color_manual(values = "blue") +  
  labs(
    x = "Bacteria", 
    y = "IQ") + 
  theme_classic() +  
  theme(legend.position = "none")  
Boxplot

# Save the Boxplot as a PNG file
ggsave("Data/IQ_Plot/3_Boxplot.png", plot = Boxplot, width = 15, height = 8)

```

## Heatmap
Number of nodes shared between samples

```{r}
heatmap = merge(Total_nodes_per_strain, Metadata, by.x = "ATTRIBUTE_strain", by.y = "ATTRIBUTE_strain")
heatmap = heatmap %>% select(id, ATTRIBUTE_strain, ATTRIBUTE_Bacteria)

## Create a list of unique IDs for each combination of strain and bacteria
df_grouped <- heatmap %>% 
  group_by(ATTRIBUTE_strain, ATTRIBUTE_Bacteria) %>% 
  summarise(id_list = list(unique(id)), .groups = 'drop')

## Create a nested list of IDs by bacteria and strain
id_lists <- split(df_grouped$id_list, df_grouped$ATTRIBUTE_Bacteria)

## Obtain the names of the bacteria and the strains
bacteria_names <- names(id_lists)

## Create a list of intersection matrices for each bacteria
intersect_matrices <- list()

for (bacteria in bacteria_names) {
  id_per_strain <- id_lists[[bacteria]]
  strain_names <- df_grouped$ATTRIBUTE_strain[df_grouped$ATTRIBUTE_Bacteria == bacteria]
  n_strains <- length(strain_names)
  
  # Intersection matrix for the specific bacteria
  intersect_matrix <- matrix(0, nrow = n_strains, ncol = n_strains, dimnames = list(strain_names, strain_names))
  
  for (i in 1:n_strains) {
    for (j in 1:n_strains) {
      intersect_matrix[i, j] <- length(intersect(id_per_strain[[i]], id_per_strain[[j]]))
    }
  }
  
  # Store the matrix in a list
  intersect_matrices[[bacteria]] <- intersect_matrix
}

## Convert matrices to long format
intersect_matrix_melt <- do.call(rbind, lapply(names(intersect_matrices), function(bacteria) {
  mat_melt <- as.data.frame(as.table(intersect_matrices[[bacteria]]))
  mat_melt$Bacteria <- bacteria
  return(mat_melt)
}))

intersect_matrix_melt <- na.omit(intersect_matrix_melt)

## Plot the heatmap with facets by bacteria
Heatmap <- ggplot(intersect_matrix_melt, aes(Var1, Var2, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(colours = c("white", "lightblue", "blue", "darkblue")) +
  labs(x = "", y = "", fill = "Shared nodes number") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
        axis.text.y = element_text(size = 4)) 

Heatmap
## Save the Distribution Plot as a PNG file
ggsave("Data/IQ_Plot/4_Heatmap.png", plot = Heatmap, width = 15, height = 8)


```
## Network Analysis
Edges connect nodes if IQ parameters values are similar
```{r}

# Convert to matrix
data_matrix <- as.matrix(IQ[, c("Hmqs", "Hcos", "Ans")])

# Calculate the similarity matrix using cosine distance
similarity_matrix <- 1 - proxy::dist(data_matrix, method = "cosine")

# Convert to matrix and assign row and column names
similarity_matrix <- as.matrix(similarity_matrix)
rownames(similarity_matrix) <- IQ$ATTRIBUTE_Strain
colnames(similarity_matrix) <- IQ$ATTRIBUTE_Strain

# Define threshold
threshold <- 0.995

# Create the adjacency matrix based on the threshold
adjacency_matrix <- similarity_matrix > threshold  # TRUE/FALSE

# Convert to numeric matrix (0 and 1)
adjacency_matrix <- as.numeric(adjacency_matrix)
adjacency_matrix <- matrix(adjacency_matrix, nrow = nrow(similarity_matrix), ncol = ncol(similarity_matrix))
rownames(adjacency_matrix) <- rownames(similarity_matrix)
colnames(adjacency_matrix) <- colnames(similarity_matrix)

# Create the graph from the adjacency matrix
g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# Add ATTRIBUTE_Bacteria as a vertex attribute
V(g)$bacteria <- IQ$ATTRIBUTE_Bacteria

# Export the graph as a GraphML file
write_graph(g, file = "Data/IQ_Plot/Similarity.graphml", format = "graphml")

# Create a color vector based on ATTRIBUTE_Bacteria
IQ$ATTRIBUTE_Bacteria <- as.factor(IQ$ATTRIBUTE_Bacteria)
color_vector <- rainbow(length(levels(IQ$ATTRIBUTE_Bacteria)))[as.numeric(IQ$ATTRIBUTE_Bacteria)]

# Visualize the network
plot(g, 
     vertex.label = V(g)$name, 
     edge.width = E(g)$weight * 5, 
     edge.color = "gray", 
     vertex.size = 5, 
     vertex.color = color_vector,  # Use the color vector
     main = "")

```

Top 10 lowest IQ
```{r}
# Summary of top 10 lowest IQ
IQ_Summary_top <- IQ_T %>%
  arrange(IQ) %>%
  slice_head(n = 10)
```

## Top 10 plots
### IQ by strain
```{r}

IQ_top_plot = ggplot(IQ_Summary_top, aes(x = reorder(ATTRIBUTE_Strain, -IQ), y = IQ, fill = ATTRIBUTE_Bacteria)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "Black", width = 0.7, show.legend = TRUE) +  
  theme_classic() + 
  labs(x = "",
       y = "IQ",
       fill = "Bacteria") +  # Legend label
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),  
    axis.text.x = element_text(angle = 90, hjust = 1, size = 10),  
    axis.text.y = element_text(size = 14),  
    axis.title = element_text(face = "bold"),  
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),  
    legend.title = element_text(size = 14)  
  )+ scale_fill_viridis_d()

IQ_top_plot 

## Save the plot
ggsave("Data/IQ_Plot/5_IQ_top_Plot.png", plot = IQ_top_plot, width = 15, height = 8)


```

### Distribution top plot
```{r}

## Distribution top plot data
summary_top_data <- IQ_Summary_top %>%
  group_by(ATTRIBUTE_Bacteria) %>%
  summarise(
    mean_IQ = mean(IQ, na.rm = TRUE),
    sd_IQ = sd(IQ, na.rm = TRUE),
    .groups = 'drop'
  )


Distribution_top_plot = ggplot() +
  geom_point(data = IQ_Summary_top, aes(x = ATTRIBUTE_Bacteria, y = IQ), 
             shape = 1, color = "blue", size = 1.5, alpha = 0.6) +  # Points for individual IQ values
  geom_errorbar(data = summary_top_data, 
                aes(x = ATTRIBUTE_Bacteria, ymin = mean_IQ - sd_IQ, ymax = mean_IQ + sd_IQ), 
                width = 0.1, color = "Black") +  # Error bars for mean IQ
  geom_point(data = summary_top_data, aes(x = ATTRIBUTE_Bacteria, y = mean_IQ), 
             shape = 1, color = "blue", size = 1) +  # Points for mean IQ
  labs(
    x = "Bacteria", 
    y = "IQ") +
  theme_classic() 

Distribution_top_plot
# Save the distribution plot
ggsave("Data/IQ_Plot/6_Distribution_top_plot.png", plot = Distribution_top_plot, width = 15, height = 8)

```

### Heatmap

```{r}

heatmap_top = merge(heatmap, IQ_Summary_top, by.x = "ATTRIBUTE_strain", by.y = "ATTRIBUTE_Strain")
heatmap_top = heatmap_top %>% select(id, ATTRIBUTE_strain, ATTRIBUTE_Bacteria.x)
colnames(heatmap_top) = c("id", "ATTRIBUTE_strain", "ATTRIBUTE_Bacteria")

## Create a list of unique IDs for each strain and bacteria combination
df_grouped_top <- heatmap_top %>% 
  group_by(ATTRIBUTE_strain, ATTRIBUTE_Bacteria) %>% 
  summarise(id_list = list(unique(id)))

## Create a nested list of IDs by bacteria and strain
id_lists_top <- split(df_grouped_top$id_list, df_grouped_top$ATTRIBUTE_Bacteria)

## Get the names of the bacteria and strains
bacteria_names_top <- names(id_lists_top)

## Create a list of intersection matrices for each bacteria
intersect_matrices_top <- list()

for (bacteria in bacteria_names_top) {
  id_per_strain_top <- id_lists_top[[bacteria]]
  strain_names_top <- df_grouped_top$ATTRIBUTE_strain[df_grouped_top$ATTRIBUTE_Bacteria == bacteria]
  n_strains_top <- length(strain_names_top)
  
  # Intersection matrix for the specific bacteria
  intersect_matrix <- matrix(0, nrow = n_strains_top, ncol = n_strains_top, dimnames = list(strain_names_top, strain_names_top))
  for (i in 1:n_strains_top) {
    for (j in 1:n_strains_top) {
      intersect_matrix[i, j] <- length(intersect(id_per_strain_top[[i]], id_per_strain_top[[j]]))
    }
  }
  
  # Store the matrix in a list
  intersect_matrices_top[[bacteria]] <- intersect_matrix
}

## Convert the matrices to long format
intersect_matrix_melt_top <- do.call(rbind, lapply(names(intersect_matrices_top), function(bacteria) {
  mat_melt <- as.data.frame(as.table(intersect_matrices_top[[bacteria]]))  # Updated to intersect_matrices_top
  mat_melt$Bacteria <- bacteria
  return(mat_melt)
}))

## Plot the heatmap with facets by bacteria
Heatmap_top <- ggplot(intersect_matrix_melt_top, aes(Var1, Var2, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(colours = c("white", "lightblue", "blue", "darkblue")) +
  labs(x = "", y = "", fill = "Shared nodes number") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8)) 
Heatmap_top

# Save the distribution plot
ggsave("Data/IQ_Plot/7_Heatmap_top_plot.png", plot = Heatmap_top, width = 15, height = 8)

```

### Network analysis
```{r}

# Convert to matrix
data_matrix <- as.matrix(IQ_Summary_top[, c("Hmqs", "Hcos", "Ans")])

# Calculate the similarity matrix using cosine distance
similarity_matrix <- 1 - proxy::dist(data_matrix, method = "cosine")

# Convert to matrix and assign row and column names
similarity_matrix <- as.matrix(similarity_matrix)
rownames(similarity_matrix) <- IQ_Summary_top$ATTRIBUTE_Strain
colnames(similarity_matrix) <- IQ_Summary_top$ATTRIBUTE_Strain

# Define threshold
threshold <- 0.995

# Create the adjacency matrix based on the threshold
adjacency_matrix <- similarity_matrix > threshold  # TRUE/FALSE

# Convert to numerical matrix (0 and 1)
adjacency_matrix <- as.numeric(adjacency_matrix)
adjacency_matrix <- matrix(adjacency_matrix, nrow = nrow(similarity_matrix), ncol = ncol(similarity_matrix))
rownames(adjacency_matrix) <- rownames(similarity_matrix)
colnames(adjacency_matrix) <- colnames(similarity_matrix)

# Create the graph from the adjacency matrix
g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# Ensure ATTRIBUTE_Bacteria is character or factor
IQ_Summary_top$ATTRIBUTE_Bacteria <- as.character(IQ_Summary_top$ATTRIBUTE_Bacteria)

# Add ATTRIBUTE_Bacteria as a vertex attribute
V(g)$bacteria <- IQ_Summary_top$ATTRIBUTE_Bacteria

# Export the graph as a GraphML file
write_graph(g, file = "Data/IQ_Plot/Top_graphlm.graphml", format = "graphml")

# Create a color vector based on ATTRIBUTE_Bacteria
IQ_Summary_top$ATTRIBUTE_Bacteria <- as.factor(IQ_Summary_top$ATTRIBUTE_Bacteria)
color_vector <- rainbow(length(levels(IQ_Summary_top$ATTRIBUTE_Bacteria)))[as.numeric(IQ$ATTRIBUTE_Bacteria)]

# Visualize the network
plot(g, 
     vertex.label = V(g)$name, 
     edge.width = E(g)$weight * 5, 
     edge.color = "gray", 
     vertex.size = 30, 
     vertex.color = color_vector,  # Use the color vector
     main = "")

```

# Bini integration

Load and prepare BiNi results
```{r}

BiNI_results <- read_excel("Data/BiNI_results.xlsx")


IQ_BiNI <- merge(IQ, BiNI_results, by.x = "ATTRIBUTE_Strain", by.y = "Strain")
IQ_BiNI_long <- IQ_BiNI %>% select(ATTRIBUTE_Bacteria, ATTRIBUTE_Strain, IQ, BiNI)

# IQ-BiNi plot
IQ_BiNI_long <- IQ_BiNI_long %>%
  pivot_longer(
    cols = -c(ATTRIBUTE_Strain, ATTRIBUTE_Bacteria),
    names_to = "Parameter",    
    values_to = "Value"        
  )

```
## Plots
### IQ-BiNI distribution
```{r}

# Create a custom cadet blue color gradient
palette <- colorRampPalette(c("#5F9EA0", "#4682B4", "#2F4F4F"))(length(unique(IQ_BiNI_long$ATTRIBUTE_Bacteria)))

# Create the plot with dynamically generated aquamarine colors
# Create the plot
IQ_BiNI_Plot <- ggplot(IQ_BiNI_long, aes(x = ATTRIBUTE_Strain, y = Value, color = ATTRIBUTE_Bacteria, shape = Parameter)) +
  geom_point(size = 3, alpha = 0.8) +  # Add transparency for better overlap handling
  labs(
    title = "",
    x = "",
    y = ""
  ) +
  theme_classic(base_size = 14) +  # Base font size increased for better readability
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 22),  # Rotate x-axis labels for better fit
    axis.text.y = element_text(size = 22),
    axis.title.x = element_text(size = 12, margin = margin(t = 22)),  # Add margin to the x label
    axis.title.y = element_text(size = 12, margin = margin(r = 22)),
    legend.text = element_text(size = 22),  
    legend.title = element_text(size = 22)
  ) +
  ylim(0, 1) +
  scale_shape_manual(values = c(16, 17)) +  # Shape 16 for IQ, shape 17 for BiNI
  scale_color_manual(values = palette) +  # Use the defined aquamarine palette
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray") +
  scale_color_viridis_d() 

IQ_BiNI_Plot

ggsave("Data/IQ_Plot/10_IQ_BiNI_plot.png", plot = IQ_BiNI_Plot, width = 15, height = 8)

```

### Regression

```{r}

# scatter plot IQ_BiNI
# Define a color palette

palette <- brewer.pal(n = length(unique(IQ_BiNI$ATTRIBUTE_Bacteria)), name = "Set2")
correlation <- cor(IQ_BiNI$BiNI, IQ_BiNI$IQ, use = "complete.obs")  


IQ_BiNI_SPlot <- ggplot(IQ_BiNI, aes(x = IQ, y = BiNI, color = ATTRIBUTE_Bacteria)) +
  geom_point(size = 4, alpha = 0.7) +  # Adjusting point transparency and size
  geom_smooth(method = "lm", linetype = "dashed", color = "black", fill = "lightgray") +  # Confidence interval
  labs(title = "",
       x = "IQ",
       y = "BiNI") +
  theme_classic() +
  theme(
    axis.text = element_text(size = 12),  # Increase axis text size
    axis.title = element_text(size = 14),  # Increase axis title size
    plot.title = element_text(hjust = 0.5, size = 16)  # Center and increase plot title size
  ) +
  annotate("text", x = Inf, y = Inf, label = paste("R: ", round(correlation, 2)), 
           hjust = 3, vjust = 10, size = 5, color = "black") +
  scale_color_viridis_d() 
IQ_BiNI_SPlot


ggsave("Data/IQ_Plot/11_IQ_BiNI_SPlot.png", plot = IQ_BiNI_SPlot, width = 15, height = 8)

```
